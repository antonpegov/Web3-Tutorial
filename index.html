<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Добро пожаловать в Ethereum )</title>

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <link rel="stylesheet" type="text/css" href="main.css">
  <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.0.0-beta.34/dist/web3.min.js"></script>

</head>

<body>
  <div class="container">

    <h1>Вводная инструкция по использованю Web3 v1.0</h1>

    <div class="card">
      <!-- <img class="card-img-top" src=".../100px180/" alt="Card image cap"> -->
      <div class="card-body">
        <h5 class="card-title">1. Введение</h5>
        <p class="card-text">Web3.js - официальная библиотека для работы с блокчейном Ethereum. В версии 1.0 добавлены важные и полезные фичи,
          делающие работу с библиотекой удобной и приятной: добавлены расширенные промисы (PromiEvents),
          появилась возможность подписываться на события (к сожалению не поддерживатся текущей версией Metamask),
          произошло структурирование на функциональные модули и многое другое.
        </p>
        <p class="card-text">Web3 позволяет нам абстрагироваться от внутренней механики Ethereum и работать с сетью и смарт-контрактами так, будто это обычные javascript-объекты.
          Если вы еще не знаете, что такое смарт-контракты, то можете представить их как некие классы - на самом деле это действительно классы языка Solidium,
          который, кстати, внешне очень похож на javascript. Процесс выглядит следующим образом: код смарт-контракта пишется на Solidium, потом компилируется в байт-код и этот байт-код записывается в сеть.
          Размещение (другими словами деплой, запись) контракта в сети можно сравнить с созданием экземпляра объекта в javascript.
          Как вновь созданный объект javascript получает свой адрес в "куче", так размещённый нами контракт получает свой адрес в сети Ethereum,
          используя который мы теперь можем вызывать его методы и читать свойства. Ну почти. На самом деле для всех публичных свойств автоматически создаются геттеры -
          одноимённые методы для получения значения этих свойств. Любое обращение к смарт-контракту происходит через вызов его методов. И теперь самое важное - есть два типа методов:
          те, которые меняют состояние смарт-контракта и те, которые не меняют. Первые требуют на своё выполнение затрат эфира, т.к. приводят к записи данных в сеть Ethereum,
          а вторые совершенно бесплатны, их ещё называют view-методы. Как упоминалось выше, они автоматически создаются для всех публичных свойств смарт-контракта.
          Как видите, всё просто, нам остаётся подключиться к смарт-контракту, получив от web3 javascript-объект, представляющий его абстракцию.
          У этого объекта есть свойство methods, которое представляет набор методов смарт-контракта. View-методы вызываем методом .call(), а остальные методом .send().
          Эти методы возвращают нам объект класса PromiEvent - мутант промиса и эвента. Смысл в том, что в случае записи данных этот промис разрешится только тогда, когда данные будут записаны в сеть,
          ждать чего может прийтись от десатков до сотен секунд. В это время мы можем слушать различные события, происходящие в процессе выполнении нашего метода и реагировать на них.
        </p>
        <p class="card-text">Для подключения к блокчейну, мы должны предоставить библиотеке web3 так называемый провайдер - сущность, которая непосредственно будет обмениваться данными
          с узлом Ethereum на машинном языке, в который web3 переведёт наши команды. Есть несколько способов получить этого провайдера:
          установить браузерное раcшиение <a href="https://metamask.io/">Metamask</a> (работает как прокси между вами и вашим адресом в сети, позволяя не инсталлировать свой полноценный узел)
          или установить на локальную машину узел Ethereum (для тестирования можно использовать его эмулятор, например <a href="http://truffleframework.com/ganache/">Ganache</a>)
          В данной инструкции мы рассмотрим самый простой, первый вариант. Для того, чтобы не тратить реальные деньги, подключаться будем не к основной сети Ethereum,
          а к её тестовой копии - <a href="https://www.rinkeby.io">Rinkeby</a>. Она позволяет получить бесплатные виртуальные Эфиры, которые вы потом сможете тратить: <a href="https://www.rinkeby.io/#faucet">Ссылка</a>.
        </p>
        <p class="card-text">Полезные ссылки:</p>
        <p class="card-text"><a href="https://www.youtube.com/watch?v=92pdrRH_VGA" target=_blank>Выступление автора библиотеки Fabian Vogelsteller</a></p>
        <p class="card-text"><a href="https://coursetro.com/courses/20/Developing-Ethereum-Smart-Contracts-for-Beginners" target=_blank>Подробный туториал по раборе со смарт-контрактами Ethereum</a></p>
        <p class="card-text"><a href="https://web3js.readthedocs.io/en/1.0/" target=_blank>Полная документация библиотеки web3.js</a></p>
      </div>
    </div>

    <div class="card">
      <div class="card-body">
        <h5 class="card-title">2. Настройка</h5>
        <p class="card-text">Для начального сетапа вы можете использовать непосредственно данный туториал, мы специально сделали его максимально простым. Итак, первым делом установите <a href="https://metamask.io/">Metamask</a>.</p>
        <p class="card-text">Используя Метамаск, зарегистрируйте себе новый кошелек Ethereum или подключите уже имеющийся, импортировав его секретный ключ. </p>
        <p class="card-text">Импортируйте удобным для вас способом библиотеку <a href="https://github.com/ethereum/web3.js/tree/1.0">web3</a>. Мы использовали этот <a href="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.0.0-beta.34/dist/">CDN</a>.</p>
        <p class="card-text">Теперь давайте подключимся к сети Ethereum, для чего "попросим" Метамаск поделиться с нами своим провайдером: </p>
        <pre class="prettyprint">
          // Web3 - класс, который мы импортировали с библиотекой web3
          // window.web3 - прокси, созданный Метамаском. Из него мы сможем достать так нужного нам провайдера.
          function checkAndInstantiateWeb3() {
            try {
              if (window.web3 !== 'undefined') {
                console.log("Using Metamask's web3 provider");
                return new Web3(window.web3.currentProvider);
              } else {
                console.warn('No web3 detected. Falling back to http://localhost:8545.');
                return new Web3(new this.Web3.providers.HttpProvider('http://localhost:8545'));
              }
            } catch(e) {
              console.error("Sorry, can't find any web3 provider:", e.message)
            }
          }
        </pre>
        <p class="card-text">Здесь мы пробуем найти Метамаск, а если его нет, пытаемся подключиться к локальному узлу Ethereum и взять провайдер оттуда.</p>
      </div>
    </div>

    <div class="card">
      <div class="card-body">
        <h5 class="card-title">2. Подключение.</h5>
        <p class="card-text">
          В данном туториале мы не будем подробно останавливаться на процессе написания 
          и компиляции самого контракта, за этой информацией просим вас обратиться к углубленному туториалу, 
          ссылка на который была дана в первом разделе. Тем не менее, давайте для тренировки давайте задеплоим 
          контракт из этого проекта: <a href="https://github.com/bankex/ERC20DividendsToken">ERC20DividendsToken</a>.</p>
          В кратце, данный смарт-контракт, далее для удобства будем истользовать термин'класс', определяет некий объект, 
          которым можно обмениваться с другими пользователями. Если посмотреть код, вы увидите, что эти характеристики 
          определяются в базовом классе ERC20Token (файл ERC20Token.sol). Да, классы в Solidity поддерживают наследование. 
          Класс ERC20DividendsToken расширяет ERC20Token функционалом, позволяющим начислять на нашу сущность дивиденды в эфирах, 
          так что все, кто имеет эти токены в своём Ethereum-кошельке, получает свою долю пропорционально количеству имеющихся токенов. 
          Если проводить аналогию с реальным миром, это фактически выпуск акций - представьте, что размещая контракт в сети, 
          вы выпускаете определённое количество акции своей компании, после чего можете их передавать другим лицам и начислять на них дивиденды. 
          Наконец в классе VendingToken, унаследованном от ERC20DividendsToken, мы выпускаем 100 наших акций-токенов. 
          Назначение данного смарт-контракта - "токенизация" некоего бизнес-актива, причём 1 токен представляет 1% стоимости этого актива.
          Этот контракт мы и будем размещать в сети. 
        </p>
        <p class="card-text">
          Мы опустим процесс компиляции и сразу возьмём байт-код скомпилированного контракта, чтобы задеплоить его в сеть. 
          Если вы захотите сами получить байткод и ABI(Application Binary Interface), то самый простой путь - забрать себе проект, 
          установить npm пакет 'remixd' и открыть доступ к папке с контрактами командой 'remixd -s contracts', затем
          открыть в браузере онлайн IDE для Solidity <a href="http://remix.ethereum.org" target="_blank">Remix</a>, 
          подключиться к открытой ранее папке (иконка с цепью), открыть файл VendingToken.sol, 
          скомпилировать кнопкой 'Start to compile' (убедитесь, что в селекте выбран правильный контракт), 
          потом нажать кнопку 'Details'. В появившемся окошке нас интересуют две сущности - 'BYTECODE', 
          а именно подраздел "object", копируем его значение и сохраняем в переменную. Теперь находим раздел 'ABI' 
          и сохраняем его в другую переменную. ABI позволит web3 "расшифровать" параметры методов нашего скомпилированного контракта, 
          иначе он для нас останется бессвязным набором символов. Все вышеперечисленные действия мы уже произвели и сохранили
          байткод и ABI в файле data.js
        </p>
        <p class="card-text">
          Итак, используя уже созданниый инстранс web3, "заряженный" провайдером, взятым у Метамаска, создадим инстанс абстракции контракта:
        </p>
        <pre class="prettyprint">
            var w3, myAddress, myContract;
            $(document).ready((x) => {
              try {
                w3 = checkAndInstantiateWeb3();
                myContract = new w3.eth.Contract(abi);        
              } catch(err) {
                console.error(err);
              }
            })
        </pre>
        <p class="card-text">Если бы у нас уже был задеплоенный контракт, 
          то нам было бы дастаточно указать его адрес вторым параметром метода Contract(), но мы хотим сами его задеплоить и
          для этого используем имеющийся у нас байткод и метод deploy(). Перед деплоем убедитесь, что вы вошли в Метамаск и 
          переключились на тестовую сеть Rinkeby!
        </p>
        <pre class="prettyprint">
            $('#deployBtn').click(async() => {
              try {
                resetContractData();                                          // Очищаем старые данные
                $('#deployBtn')[0].disabled = true;                           // Блокируем кнопку
                const accounts = await w3.eth.getAccounts();                  // Получаем адреса кошелька, выбранного в Метамаске
                myAddress = accounts[0];                                      
                if(!accounts[0]) { alert('Кошелёк не найден, войдите в Метамаск и создайте кошелёк!'); return; }
                const transaction = myContract.deploy({data: bytecode});      // Формируем транзакцию
                const promiEvent = transaction.send({from: myAddress});       // Отправляем транзакцию на запись в Блокчейн
                promiEvent.on('transactionHash', onTransactionHashReceived);  // Вешаем на промивент обработчик события 'transactionHash'
                promiEvent.on('error', resetVisualEffects);                   // Сбросить блокировки, если пользователь отменил транзакцию
                promiEvent.then(newContractInstance => {
                  myContract = newContractInstance;                                   // Обновляем нашу абстракцию контракта
                  $('#contractAddress a')[0].innerText = myContract.options.address;  // Показываем адрес задеплоенного контракта в сети
                  $('#contractAddress a')[0].href = 'https://rinkeby.etherscan.io/address/' + myContract.options.address;
                  resetVisualEffects();
                });
              } catch(err) {
                resetVisualEffects();
                console.error(err);
              }
            })
        </pre>
        <p class="card-text">
          Код вспомогательных функций resetContractData(), onTransactionHashReceived(), resetVisualEffects() можно посмотреть в файле connect.js, 
          разберём процесс деплоя подробнее. Любая запись информации в блокчейн происходит посредством формирования и отправки специального объекта,
          называемого транзакцией, который майнеры помещают в новый блок. Отправка производится методом send(), который возвращает объект класса PromiEvent, 
          позволяющий не только ждать окончания майнинга нового блока, но и контролировать этот процесс. Майнеры получают вашу транзакцию и, 
          если она их устраивает, начинают записывать её в следующий блок, предварительно вернув вам "расписку в получении" - transaction hash. 
          По окончаню процесса майнинга блока PromEvent резолвится и мы получаем наш новенький только что задеплоенный контракт.
        </p>
        <p><button id="deployBtn">Deploy Contract</button> <img id="deploySpinner" src="./assets/cool-spinner.gif" class="spinner" alt="spinner"></p> 
        <p class="card-text" id="deployHash"><i>Transaction hash: </i><b><a target="_blank"></a></b></p>
        <p class="card-text" id="contractAddress"><i>Contract address: </i><b><a target="_blank"></a></b></p>
        <p class="card-text">* данные по ссылкам могут отображаться с задержкой</p>
      </div>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
  <script src="js/data.js"></script>
  <script src="js/connect.js"></script>
  <script src="js/main.js"></script>

</body>

</html>
