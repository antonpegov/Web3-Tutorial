<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Добро пожаловать в Ethereum )</title>

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <link rel="stylesheet" type="text/css" href="main.css">
  <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.0.0-beta.34/dist/web3.min.js"></script>

</head>

<body>
  <div class="container">

    <h1>Вводная инструкция по использованю Web3 v1.0</h1>

    <div class="card">
      <!-- <img class="card-img-top" src=".../100px180/" alt="Card image cap"> -->
      <div class="card-body">
        <h5 class="card-title">1. Введение</h5>
        <p class="card-text">Web3.js - официальная библиотека для работы с блокчейном Ethereum. В версии 1.0 добавлены важные и полезные фичи,
          делающие работу с библиотекой удобной и приятной: добавлены расширенные промисы (PromiEvents),
          появилась возможность подписываться на события (к сожалению не поддерживатся текущей версией Metamask),
          произошло структурирование на функциональные модули и многое другое.
        </p>
        <p class="card-text">Web3 позволяет нам абстрагироваться от внутренней механики Ethereum и работать с сетью и смарт-контрактами так, будто это обычные javascript-объекты.
          Если вы еще не знаете, что такое смарт-контракты, то можете представить их как некие классы - на самом деле это действительно классы языка Solidium,
          который, кстати, внешне очень похож на javascript. Процесс выглядит следующим образом: код смарт-контракта пишется на Solidium, потом компилируется в байт-код и этот байт-код записывается в сеть.
          Размещение (другими словами деплой, запись) контракта в сети можно сравнить с созданием экземпляра объекта в javascript.
          Как вновь созданный объект javascript получает свой адрес в "куче", так размещённый нами контракт получает свой адрес в сети Ethereum,
          используя который мы теперь можем вызывать его методы и читать свойства. Ну почти. На самом деле для всех публичных свойств автоматически создаются геттеры -
          одноимённые методы для получения значения этих свойств. Любое обращение к смарт-контракту происходит через вызов его методов. И теперь самое важное - есть два типа методов:
          те, которые меняют состояние смарт-контракта и те, которые не меняют. Первые требуют на своё выполнение затрат эфира, т.к. приводят к записи данных в сеть Ethereum,
          а вторые совершенно бесплатны, их ещё называют view-методы. Как упоминалось выше, они автоматически создаются для всех публичных свойств смарт-контракта.
          Как видите, всё просто, нам остаётся подключиться к смарт-контракту, получив от web3 javascript-объект, представляющий его абстракцию.
          У этого объекта есть свойство methods, которое представляет набор методов смарт-контракта. View-методы вызываем методом .call(), а остальные методом .send().
          Эти методы возвращают нам объект класса PromiEvent - мутант промиса и эвента. Смысл в том, что в случае записи данных этот промис разрешится только тогда, когда данные будут записаны в сеть,
          ждать чего может прийтись от десатков до сотен секунд. В это время мы можем слушать различные события, происходящие в процессе выполнении нашего метода и реагировать на них.
        </p>
        <p class="card-text">Для подключения к блокчейну, мы должны предоставить библиотеке web3 так называемый провайдер - сущность, которая непосредственно будет обмениваться данными
          с узлом Ethereum на машинном языке, в который web3 переведёт наши команды. Есть несколько способов получить этого провайдера:
          установить браузерное раcшиение <a href="https://metamask.io/">Metamask</a> (работает как прокси между вами и вашим адресом в сети, позволяя не инсталлировать свой полноценный узел)
          или установить на локальную машину узел Ethereum (для тестирования можно использовать его эмулятор, например <a href="http://truffleframework.com/ganache/">Ganache</a>)
          В данной инструкции мы рассмотрим самый простой, первый вариант. Для того, чтобы не тратить реальные деньги, подключаться будем не к основной сети Ethereum,
          а к её тестовой копии - <a href="https://www.rinkeby.io">Rinkeby</a>. Она позволяет получить бесплатные виртуальные Эфиры, которые вы потом сможете тратить: <a href="https://www.rinkeby.io/#faucet">Ссылка</a>.
        </p>
        <p class="card-text">Полезные ссылки:</p>
        <p class="card-text"><a href="https://www.youtube.com/watch?v=92pdrRH_VGA" target=_blank>Выступление автора библиотеки Fabian Vogelsteller</a></p>
        <p class="card-text"><a href="https://coursetro.com/posts/code/99/Interacting-with-a-Smart-Contract-through-Web3.js-(Tutorial)" target=_blank>Подробный туториал по раборе со смарт-контрактами Ethereum</a></p>
        <p class="card-text"><a href="https://web3js.readthedocs.io/en/1.0/" target=_blank>Полная документация библиотеки web3.js</a></p>
      </div>
    </div>

    <div class="card">
      <div class="card-body">
        <h5 class="card-title">2. Настройка</h5>
        <p class="card-text">Для начального сетапа вы можете использовать непосредственно данный туториал, мы специально сделали его максимально простым. Итак, первым делом установите <a href="https://metamask.io/">Metamask</a>.</p>
        <p class="card-text">Используя Метамаск, зарегистрируйте себе новый кошелек Ethereum или подключите уже имеющийся, импортировав его секретный ключ. </p>
        <p class="card-text">Импортируйте удобным для вас способом библиотеку <a href="https://github.com/ethereum/web3.js/tree/1.0">web3</a>. Мы использовали этот <a href="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.0.0-beta.34/dist/">CDN</a>.</p>
        <p class="card-text">Теперь давайте подключимся к сети Ethereum, для чего "попросим" Метамаск поделиться с нами своим провайдером: </p>
        <pre class="prettyprint">
          // Web3 - класс, который мы импортировали с библиотекой web3
          // window.web3 - прокси, созданный Метамаском. Из него мы сможем достать так нужного нам провайдера.
          function checkAndInstantiateWeb3() {
            try {
              if (window.web3 !== 'undefined') {
                console.log("Using Metamask's web3 provider");
                return new Web3(window.web3.currentProvider);
              } else {
                console.warn('No web3 detected. Falling back to http://localhost:8545.');
                return new Web3(new this.Web3.providers.HttpProvider('http://localhost:8545'));
              }
            } catch(e) {
              console.error("Sorry, can't find any web3 provider:", e.message)
            }
          }
        </pre>
        <p class="card-text">Здесь мы пробуем найти Метамаск, а если его нет, пытаемся подключиться к локальному узлу Ethereum и взять провайдер оттуда.</p>
      </div>
    </div>

    <div class="card">
      <div class="card-body">
        <h5 class="card-title">2. Подключение.</h5>
        <p class="card-text">
          В данном туториале мы не будем подробно останавливаться на процессе написания 
          и компиляции самого контракта, для этого просим вас обратиться к углубленному туториалу, 
          ссылка на который была дана в первом пункте. Тем не менее, давайте для тренировки задеплоим 
          контракт из этого проекта: <a href="https://github.com/bankex/ERC20DividendsToken">ERC20DividendsToken</a>.</p>
          В кратце, данный смарт-контракт представляет собой некую, определяемую при деплое, 
          коллекцию из нескольких наборов токенов (стандартные сущности, которыми можно обмениваться), 
          которые можно переводить длугим пользователям. Но главное, на них можно 
          начислять дивиденды в эфирах, и все, кто имеет эти токены в своём Ethereum-кошельке, 
          получат свою долю пропорционально количеству имеющихся токенов. Если проводить аналогию с реальным миром, 
          это похоже на выпуск акций - представьте, что размещая контракт в сети, вы сразу выпускаете сдандартные, 
          привилегированные и ещё какие-нибудь акции своей компании, после чего можете их передавать другим лицам и начислять на них дивиденды. 
        </p>
        <p class="card-text">
          Итак, мы опустим процесс компиляции 
          и сразу возьмём байт-код скомпилированного контракта чтобы задеплоить его в сеть с желаемыми параметрами. 
          Если вы захотите сами получить байткод и abi(см.ниже что это), то самый простой путь - забрать себе проект, 
          установить npm пакет 'remixd' и открыть доступ к папке с контрактами командой 'remixd -s contracts'. Затем
          открыть в браузере онлайн IDE для Solidity <a href="http://remix.ethereum.org" target="_blank">Remix</a>, 
          подключиться к открытой ранее папке (иконка с цепью), открыть файл ERC20DividendsToken.sol, 
          скомпилировать кнопкой 'Start to compile' (убедившись что в селекте выбран правильный контракт), 
          потом нажать кнопку 'Details'. В появившемся окошке нас интересуют две сущности - BYTECODE, 
          а именно подраздел "object", копируем его значение и сохраняем в переменную. Теперь находим раздел ABI 
          и сохраняем его в другую переменную. Abi позволит web3 "расшифровать" параметры методов нашего скомпилированного контракта, 
          иначе он для нас останется бессвязным набором символов. Все перечисленные выше действия мы уже произвели и сохранили
          байткод и аби в файле data.js
        </p>
        <p class="card-text">
          Итак, используя уже созданниый инстранс web3, "заряженный" провайдером, взятым у Метамаска, создаём инстанс контракта:
        </p>
        <pre class="prettyprint">
            $(document).ready((x) => {
              try {
                const w3 = checkAndInstantiateWeb3();
                const contract = new w3.eth.Contract(abi);
              } catch(err) {
                console.error(err);
              }
            })
        </pre>
        <p class="card-text">Если бы у нас уже был задеплоенный контракт, 
          то нам было бы дастаточно указать его адрес вторым параметром метода Contract(), но мы хотим сами его задеплоить и
           для этого используем имеющийся у нас байткод и метод deploy():
        </p>
        <pre class="prettyprint">
          myContract.deploy(options);
        </pre>
      </div>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
  <script src="js/data.js"></script>
  <script src="js/init.js"></script>
  <script src="js/connect.js"></script>

  <script>
    $(document).ready((x) => {
      try {
        const w3 = checkAndInstantiateWeb3();
        const myContract = new w3.eth.Contract(abi);
        myContract.deploy(options);
      } catch(err) {
        console.error(err);
      }
    })
  </script>

</body>

</html>
