<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Добро пожаловать в Ethereum )</title>

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <link rel="stylesheet" type="text/css" href="main.css">
  <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.0.0-beta.34/dist/web3.min.js"></script>

</head>

<body>
  <div class="container">

    <h1>Вводная инструкция по использованю Web3 v1.0</h1>

    <div class="card">
      <!-- <img class="card-img-top" src=".../100px180/" alt="Card image cap"> -->
      <div class="card-body">
        <h5 class="card-title">1. Введение</h5>
        <p class="card-text">Web3.js - официальная библиотека для работы с блокчейном Ethereum. В версии 1.0 добавлены важные и полезные фичи,
          делающие работу с библиотекой удобной и приятной: добавлены расширенные промисы (PromiEvents),
          появилась возможность подписываться на события (к сожалению не поддерживатся текущей версией Metamask),
          произошло структурирование на функциональные модули и многое другое.
        </p>
        <p class="card-text">Web3 позволяет нам абстрагироваться от внутренней механики Ethereum и работать с сетью и смарт-контрактами так, будто это обычные javascript-объекты.
          Если вы еще не знаете, что такое смарт-контракты, то можете представить их как некие классы - на самом деле это действительно классы языка Solidium,
          который, кстати, внешне очень похож на javascript. Процесс выглядит следующим образом: rод смарт-контракта пишется на Solidium, потом компилируется в байт-код и этот байт-код записывается в сеть.
          Размещение (другими словами деплой, запись) контракта в сети можно сравнить с созданием экземпляра объекта в javascript.
          Как вновь созданный объект javascript получает свой адрес в "куче", так размещённый нами контракт получает свой адрес в сети Ethereum,
          используя который мы теперь можем вызывать его методы и читать свойства. Ну почти. На самом деле для всех публичных свойств автоматически создаются геттеры -
          одноимённые методы для получения значения этих свойств. Любое обращение к смарт-контракту происходит через вызов его методов. И теперь самое важное - есть два типа методов:
          те, которые меняют состояние смарт-контракта и те, которые не меняют. Первые требуют на своё выполнение затрат эфира, т.к. приводят к записи данных в сеть Ethereum,
          а вторые совершенно бесплатны, их ещё называют view-методы. Как упоминалось выше, они автоматически создаются для всех публичных свойств смарт-контракта.
          Как видите, всё просто, нам остаётся подключиться к смарт-контракту, получив от web3 javascript-объект, представляющий его абстракцию.
          У этого объекта есть свойство methods, которое представляет набор методов смарт-контракта. View-методы вызываем методом .call(), а остальные методом .send().
          Эти методы возвращают нам объект класса PromiEvent - мутант промиса и эвента. Смысл в том, что в случае записи данных этот промис разрешится только тогда, когда данные будут записаны в сеть,
          ждать чего может прийтись от десатков до сотен секунд. В это время мы можем слушать различные события, происходящие в процессе выполнении нашего метода и реагировать на них.
        </p>
        <p class="card-text">Для подключения к блокчейну, мы должны предоставить библиотеке web3 так называемый провайдер - сущность, которая непосредственно будет обмениваться данными
          с узлом Ethereum на машинном языке, в который web3 переведёт наши команды. Есть несколько способов получить этого провайдера:
          установить браузерное раcшиение <a href="https://metamask.io/">Metamask</a> (работает как прокси между вами и вашим адресом в сети, позволяя не инсталлировать свой полноценный узел)
          или установить на локальную машину узел Ethereum (для тестирования можно использовать его эмулятор, например <a href="http://truffleframework.com/ganache/">Ganache</a>)
          В данной инструкции мы рассмотрим самый простой, первый вариант. Для того, чтобы не тратить реальные деньги, подключаться будем не к основной сети Ethereum,
          а к её тестовой копии - <a href="https://www.rinkeby.io">Rinkeby</a>. Она позволяет получить бесплатные виртуальные Эфиры, которые вы потом сможете тратить: <a href="https://www.rinkeby.io/#faucet">Ссылка</a>.
        </p>
        <p class="card-text">Полезные ссылки:</p>
        <p class="card-text"><a href="https://www.youtube.com/watch?v=92pdrRH_VGA" target=_blank>Выступление автора библиотеки Fabian Vogelsteller</a></p>
        <p class="card-text"><a href="https://www.youtube.com/watch?v=92pdrRH_VGA" target=_blank>Подробный туториал по раборе со смарт-контрактами Ethereum</a></p>
      </div>
    </div>

    <div class="card">
      <div class="card-body">
        <h5 class="card-title">2. Настройка</h5>
        <p class="card-text">Для начального сетапа вы можете использовать непосредственно данный туториал, мы специально сделали его максимально простым. Итак, первым делом установите <a href="https://metamask.io/">Metamask</a>.</p>
        <p class="card-text">Используя Метамаск, зарегистрируйте себе новый кошелек Ethereum или подключите уже имеющийся, импортировав его секретный ключ. </p>
        <p class="card-text">Импортируйте удобным для вас способом библиотеку <a href="https://github.com/ethereum/web3.js/tree/1.0">web3</a>. Мы использовали этот <a href="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.0.0-beta.34/dist/">CDN</a>.</p>
        <p class="card-text">Теперь давайте подключимся к сети Ethereum, для чего "попросим" Метамаск поделиться с нами своим провайдером: </p>
        <pre class="prettyprint">
          var w3 = checkAndInstantiateWeb3();
          function checkAndInstantiateWeb3() {
            try {
              if (window.web3 !== 'undefined') {
                console.log("Using Metamask's web3 provider");
                return new web3(window.web3.currentProvider);
              } else {
                console.warn('No web3 detected. Falling back to http://localhost:8545.');
                return new this.Web3(new this.Web3.providers.HttpProvider('http://localhost:8545'));
              }
            } catch(e) {
              console.error("Sorry, can't find any web3 provider:", e.message)
            }
          }
        </pre>
        <p class="card-text">Здесь мы пробуем найти Метамаск, а если его нет, пытаемся подключиться к локальному узлу Ethereum и взять провайдера там.</p>
      </div>
    </div>

  </div>

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
  <script src="js/init.js"></script>
  <script src="js/connect.js"></script>
  <script>
    $(document).ready((x) => {
      var w3 = checkAndInstantiateWeb3();
    })
  </script>

</body>

</html>
